【ルール】
・クラスはアッパーキャメル、それ以外は一般的にロウワーキャメル(変数、関数名)
・関数名は、基本的に　動詞＋目的語　。ファイル名では、わかりやすい命名が基本
・ちょびっとハンガリアン記法（メンバ変数のみで、m\_　の接頭辞）

インラインは基本使わない。（テンプレートももし必要なら分けるがケースバイケース）
friend も基本使わない。
グローバル変数もシグナルのみ。g\_の接頭辞をつける。
define は、使わない。const int hoge = 10;みたいにする。

【見解が割れそうなもの】
・オペレーター不在のチャンネルはどうするべきか。
→ そもそもこれに関しては定義がない？
→ じゃあどうするべきか、不在の状況で、残った人を、先着や、最後の一人のような基準で選ぶのか、もう不在でよいと考えるか。
→ 一番楽なのは、不在で放置である。
→ そもそもチャンネルは管理する人が管理する意図で制作されている。
→ 放棄された場合、管理の意図や意思が存在しない。放棄されたなら、それは管理人が放棄したという事実があるだけ。
→ サーバーは、何かしらの空間を作りたい人にその空間を提供することが責務で、放棄された場所の子守はサーバーの役目かというと疑問。
→ （サーバーは、チャンネル空間の機能は提供する。でも、ピットクルーみたいなことをするのは、違うでしょということ）
→ 多分、コミュニティーへの介入、またはコミュニティーの自動的な安定みたいな天秤があり、歴史的に曖昧にされている。
→ 何をどのように考えるかは歴史的、文化的なものがありそう。ディフェンス力が試される（実際に減点されている人を確認。）

・POLL の引数は 0 か、−1 か、その他か。
→ 課題で要求されいているのは、IO ノンブロッキングであると理解している。
→ これは、つまり、相手の処理を終わるのを待つので、その間他の処理をしなくなることをサーバーの挙動として避けてほしいということ考える。
（ミニシェルなどでやったように、相手が FD を閉じるまで待つため、パイプで閉じ忘れがあると、処理が途中で止まるのと似てる。）
→ 一方で、POLL の引数は、ブロッキングに関係しているが、これは、ポールがイベント駆動型か、もしくは自発的なチェックであるか
→ という問題であると理解している。これは、サブジェクトにあるような相手側の処理が終わるのを待つものかというと違うのではないか。
→ 　つまり POLL の後ろの引数は、無関係であり、これの決定は、別に行われるべきだ。
→ これの選択は、−1 だとイベント駆動型で POLL を動かすか、0 で無限ループでリソースを使いチェックするかのどっちを選ぶかになる。
→ 　しかし、POLL の引数がブロッキング問題だと考えている人もいることを考えると、0 にすることで誤解や説明の手間が省けるということがある。

【やることメモ優先順位順】
・BJ のロジックの修復、計算、乱数、保有。
・議論がわかれるとろこに、方針の決定（POLL の 0、チャンネルにオペレーターは必要か問題。）
・おみくじの結果を毎度構成するのはどうなのか。
・KILL コマンド？
。チャンネルの大文字と小文字の区別をなくす（RFC 的には好ましいが、今いじる気になれない。）

・sefeSend は使わない。→EGAIN を見て、再度は駄目。

校舎でやること
・DCC の場所。

【メモ】
・nick の重複は、勝手に irssi が、解消してる？

・（基本コマンドの実装系）
・セーフ send を実装して、一つの関数で扱うことで、デバッグ（送信メッセージの解析）をしやすくする。
→ 特に、MSG＿NOSIGNAL の対策が必要と思う。戻り値のあとに errno をチェックして、リソースの問題を検討したい。OS に落とされる危険性あり。
・エラーの順番、解析に順番はあるか？

・RFC 的な観点から、構造のミスがないかが、重要（修正可能か、もしくはディフェンスが可能かという観点から）

【操作方法メモ】
・nc ::1 4444
・irssi -n naga -c localhost -p 4444
・irssi -n neko -c localhost -p 4444
・

【プロトコル】

・非ニューメリックメッセージ（コマンド）
→ サーバーとクライアント両方で発信する。
→ サーバーだとプレフィックス（サーバー識別子）が必要で、クライアントだとコマンドから直接始まる（:から始まらない）

[:prefix] command [params] :[trailing]
送信元（サーバーのみ、クライアントはサーバーで把握するので不要）　コマンド　引数（チャンネル名やユーザー）　メッセージ本文
送信の場合は、
:neko!user@host PRIVMSG #general :こんにちは、みんな！

・プレフィックスの構成
サーバーから、送る際につける。
サーバー名は、ネットワーク内で一意なら OK なはず。ft_irc で十分。
サーバークライアントで、ユーザーの行動にはプレフィックスが必要。
prefix = nickname [ "!" user ] [ "@" host ]
で構成されて、
ニックネーム！ユーザー名＠ホスト名

プレフィックスがサーバー名の場合と、クライアント名の違い
・サーバー名
リプライ、サーバー通知、PONG、NOTICE 的なやつ。
・クライアント名（クライアント駆動的なやつ）
PRIVMSG、NOTICE、JOIN、PART、QUIT、NICK、MODE

受信の場合は
PRIVMSG #general :こんにちは、みんな！

・ニューメリックメッセージ（リプライ）
→ サーバーからクライアントに送る、結果通知や、エラー報告の形式。

[:prefix] [numeric reply] [target] [:message]
サーバー名、数値リプライ、対象ユーザー、メッセージ本文の形式になる。

コマンドは大文字として処理する。
CRLF で終わる。
スペースとコロンで区切る。

・エラーのときは。

```
:<server_name> <numeric_reply> <target> :<message>
```

サーバーネームは、サーバーを区別必要がないから、固定名で良さそう。

→ サーバー返答（プレフィックスはサーバー名で、、ニューメリック）
:server <number> <nick> :message
→ コマンド通知　プレフィックスはユーザー名で、チャンネルへ中継する。
:nick!user@host COMMAND <channel> :message

【】
ホストネームは 63 文字
メッセージにヌル文字は含めない
マスクは、ワイルドカードを含むもの → 使い道不明

【irssi の挙動】
サーバーのポートを 6667 で指定で立ち上げたにもかかわらず、
クライアントを 4444 でログインしようとすると、
アプリ側で、デフォルトポートを試すようで、6667 で入ってくれる。

チャンネル参加と、クライアントアプリのチャンネル固有画面の問題になる。アルトと番号、もしくは、/window goto #gen でもいける。JOIN でも画面が切り替わる。
